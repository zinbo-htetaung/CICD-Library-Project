generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["driverAdapters"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Task {
  id       Int              @id @default(autoincrement())
  name     String
  statusId Int
  status   Status           @relation(fields: [statusId], references: [id])
  persons  TaskAssignment[]
}

model Status {
  id    Int    @id @default(autoincrement())
  text  String @unique
  tasks Task[]
}

model Person {
  id     Int              @id @default(autoincrement())
  email  String           @unique
  name   String
  avatar String?
  tasks  TaskAssignment[]
}

model TaskAssignment {
  taskId     Int
  personId   Int
  assignedAt DateTime @default(now())
  person     Person   @relation(fields: [personId], references: [id], onDelete: Cascade)
  task       Task     @relation(fields: [taskId], references: [id], onDelete: Cascade)

  @@id([taskId, personId], name: "assignmentId")
}

model book {
  id               Int             @id @default(autoincrement())
  book_name        String          @db.VarChar
  author           String          @db.VarChar
  description      String?
  no_of_copies     Int
  available_copies Int
  book_category    book_category[]
  book_progress    book_progress[]
  rent_history     rent_history[]
  review           review[]
  Queue Queue[]
  QueueHistory QueueHistory[]
}

model book_category {
  id          Int      @id @default(autoincrement())
  book_id     Int
  category_id Int
  book        book     @relation(fields: [book_id], references: [id], onDelete: Cascade)
  category    category @relation(fields: [category_id], references: [id], onDelete: Cascade)
}

model book_request {
  id           Int      @id @default(autoincrement())
  user_id      Int
  author       String?  @db.VarChar
  book_name    String   @db.VarChar
  requested_on DateTime @default(now()) @db.Timestamp(6)
  users        users    @relation(fields: [user_id], references: [id], onDelete: Cascade)
}

model category {
  id            Int             @id @default(autoincrement())
  category_name String          @db.VarChar
  book_category book_category[]
}

model rent_history {
  id            Int            @id @default(autoincrement())
  book_id       Int
  user_id       Int
  start_date    DateTime       @db.Date
  end_date      DateTime       @db.Date
  return_date   DateTime?      @db.Date
  due_status    Boolean?
  book_progress book_progress?
  book          book           @relation(fields: [book_id], references: [id], onDelete: Cascade)
  users         users          @relation(fields: [user_id], references: [id], onDelete: Cascade)
  penalty_fees penalty_fees[]
}

model review {
  id          Int       @id @default(autoincrement())
  book_id     Int
  user_id     Int
  rating      Int
  review_text String?   @db.VarChar
  posted_on   DateTime? @default(now()) @db.Timestamp(6)
  book        book      @relation(fields: [book_id], references: [id], onDelete: Cascade)
  users       users     @relation(fields: [user_id], references: [id], onDelete: Cascade)
}

model user_status {
  id                 Int   @id @default(autoincrement())
  user_id            Int
  reputation         Int   @default(100)
  current_book_count Int
  max_book_count     Int
  users              users @relation(fields: [user_id], references: [id], onDelete: Cascade)
}

model users {
  id            Int             @id @default(autoincrement())
  name          String          @unique @db.VarChar
  email         String          @unique @db.VarChar
  password      String          @db.VarChar
  address       String          @db.VarChar
  dob           DateTime        @db.Date
  role          String?
  avatar        String?
  book_progress book_progress[]
  book_request  book_request[]
  rent_history  rent_history[]
  review        review[]
  user_status   user_status[]
  Queue Queue[]
  Notification Notification[]
  QueueHistory QueueHistory[]
  messages     Message[] @relation("UserMessages")
  penalty_fees penalty_fees[]
}

model Queue {
  id            Int       @id @default(autoincrement()) 
  user_id       Int
  book_id       Int
  queue_number  Int
  is_next       Boolean   @default(false)
  created_at    DateTime  @default(now())

  users         users    @relation(fields: [user_id], references: [id], onDelete: Cascade)
  book          book     @relation(fields: [book_id], references: [id], onDelete: Cascade)
  QueueHistory  QueueHistory[]

  @@unique([book_id, queue_number])
}



model QueueHistory {
  id            Int       @id @default(autoincrement())
  user_id       Int
  book_id       Int
  queue_id      Int?
  status        String   @default("Pending") @db.VarChar // "Pending" or "Fulfilled"
  timestamp     DateTime @default(now())
  queue         Queue?     @relation(fields: [queue_id], references: [id]) 
  users         users   @relation(fields: [user_id], references: [id])
  book          book    @relation(fields: [book_id], references: [id])
}

model book_progress {
  id              Int          @id @default(autoincrement())
  rent_history_id Int          @unique
  user_id         Int
  book_id         Int
  progress        Float        @default(0)
  status          String       @default("Unread") @db.VarChar
  last_updated    DateTime     @default(now()) @updatedAt
  book            book         @relation(fields: [book_id], references: [id], onDelete: Cascade)
  rent_history    rent_history @relation(fields: [rent_history_id], references: [id], onDelete: Cascade)
  users           users        @relation(fields: [user_id], references: [id], onDelete: Cascade)
}

model Message {
  id             Int      @id @default(autoincrement())
  userId         Int      // User who sent or received the message
  sender         String   // 'user' or 'admin'
  message        String   // Message content
  createdAt      DateTime @default(now())
  replyToId      Int?     // Parent message for threaded replies
  isRead         Boolean  @default(false) // Indicates if the admin has read the message

  user           users    @relation(fields: [userId], references: [id], onDelete: Cascade, name: "UserMessages")
  parentMessage  Message? @relation("Thread", fields: [replyToId], references: [id], onDelete: Cascade)
  replies        Message[] @relation("Thread")
}

model penalty_fees {
  id              Int       @id @default(autoincrement())
  rent_history_id Int       @unique
  user_id         Int
  fees            Float
  status          Boolean   @default(false)
  paid_on         DateTime? @db.Date
  rent_history rent_history @relation(fields: [rent_history_id], references: [id], onDelete: Cascade, onUpdate: Cascade)
  users        users        @relation(fields: [user_id], references: [id], onDelete: Cascade, onUpdate: Cascade)
}

model Notification {
  id          Int       @id @default(autoincrement())
  user_id     Int
  title       String    @db.VarChar(255)
  message     String
  status      String    @default("unseen") @db.VarChar(10) // "seen" or "unseen"
  created_at  DateTime  @default(now())
  users        users     @relation(fields: [user_id], references: [id], onDelete: Cascade)
}

